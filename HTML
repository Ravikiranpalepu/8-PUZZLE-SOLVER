<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-Puzzle Solver</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            color: #333;
            background-color: #f5f7fa;
            background-image: linear-gradient(rgba(255,255,255,0.9), rgba(255,255,255,0.9)), 
                              url('data:image/svg+xml;utf8,<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="25" cy="25" r="4" fill="%2335a7f0" opacity="0.2"/><circle cx="75" cy="25" r="4" fill="%2335a7f0" opacity="0.2"/><circle cx="25" cy="75" r="4" fill="%2335a7f0" opacity="0.2"/><circle cx="75" cy="75" r="4" fill="%2335a7f0" opacity="0.2"/></svg>');
            background-size: 100px 100px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }

        .app-container {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
        }

        .board-section {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            flex: 1;
            min-width: 300px;
            background-image: linear-gradient(rgba(255,255,255,0.95), rgba(255,255,255,0.95)), 
                             url('data:image/svg+xml;utf8,<svg width="50" height="50" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="50" height="50" fill="none" stroke="%233498db" stroke-width="1" opacity="0.1"/></svg>');
            background-size: 30px 30px;
        }

        .controls-section {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            flex: 1;
            min-width: 300px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 5px;
            width: 300px;
            height: 300px;
            margin: 0 auto;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 5px;
            background-color: #3498db;
            position: relative;
            overflow: hidden;
        }

        .board:after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 100%);
            pointer-events: none;
        }

        .tile {
            background-color: #ecf0f1;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: bold;
            color: #2c3e50;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s, box-shadow 0.2s;
            user-select: none;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }

        .tile:before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: radial-gradient(circle at center, rgba(255,255,255,0.8) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tile:hover:before {
            opacity: 1;
        }

        .tile.empty {
            background-color: #3498db;
            color: transparent;
        }

        .tile:hover:not(.empty) {
            transform: scale(1.03);
            background-color: #d6eaf8;
        }

        .tile.movable {
            background-color: #f1c40f;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        .solution-section {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        .solution-step {
            padding: 8px 12px;
            margin: 5px 0;
            background-color: #e3f2fd;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
        }

        .solution-step:hover {
            background-color: #bbdefb;
        }

        .solution-step.active {
            background-color: #90caf9;
            font-weight: bold;
        }

        .stats {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
        }

        .stat-item {
            background-color: #e8f4fc;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            flex: 1;
            margin: 0 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2980b9;
        }

        .stat-label {
            font-size: 12px;
            color: #7f8c8d;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        .modal-close {
            margin-top: 20px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #3498db;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>8-Puzzle Solver</h1>
        
        <div class="app-container">
            <div class="board-section">
                <div class="board" id="board"></div>
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="moves-count">0</div>
                        <div class="stat-label">Moves</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="time-taken">0</div>
                        <div class="stat-label">Time (ms)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="states-explored">0</div>
                        <div class="stat-label">States Explored</div>
                    </div>
                </div>
            </div>
            
            <div class="controls-section">
                <div style="margin-bottom: 15px;">
                    <button id="shuffle-btn">Shuffle Board</button>
                    <button id="solve-btn">Solve Puzzle</button>
                    <button id="reset-btn">Reset</button>
                </div>
                
                <div>
                    <p>Click tiles adjacent to the empty space to move them.</p>
                    <p>Or use arrow keys to slide tiles (select board first).</p>
                </div>
                
                <div class="solution-section" id="solution">
                    <p style="text-align: center; color: #7f8c8d;">Solution will appear here</p>
                </div>
                
                <div style="margin-top: 15px;">
                    <button id="prev-btn" disabled>Previous</button>
                    <button id="next-btn" disabled>Next</button>
                    <button id="play-btn" disabled>Play Solution</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="loading-modal">
        <div class="modal-content">
            <h2>Solving Puzzle</h2>
            <div style="display: flex; justify-content: center; align-items: center;">
                <div class="loading"></div>
                <span>Finding solution...</span>
            </div>
            <div id="solve-progress"></div>
            <button class="modal-close" id="cancel-solve">Cancel</button>
        </div>
    </div>

    <script>
        // Game state
        const state = {
            board: [[1, 2, 3], [4, 5, 6], [7, 8, 0]],
            emptyPos: { row: 2, col: 2 },
            solution: [],
            currentStep: -1,
            autoPlayInterval: null,
            isSolving: false,
            cancelSolve: false,
            stats: {
                moves: 0,
                timeTaken: 0,
                statesExplored: 0
            }
        };

        // DOM elements
        const boardEl = document.getElementById('board');
        const solutionEl = document.getElementById('solution');
        const shuffleBtn = document.getElementById('shuffle-btn');
        const solveBtn = document.getElementById('solve-btn');
        const resetBtn = document.getElementById('reset-btn');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const playBtn = document.getElementById('play-btn');
        const loadingModal = document.getElementById('loading-modal');
        const cancelSolveBtn = document.getElementById('cancel-solve');
        const movesCountEl = document.getElementById('moves-count');
        const timeTakenEl = document.getElementById('time-taken');
        const statesExploredEl = document.getElementById('states-explored');
        const solveProgressEl = document.getElementById('solve-progress');

        // Initialize the board
        function initBoard() {
            boardEl.innerHTML = '';
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const value = state.board[row][col];
                    const tile = document.createElement('div');
                    tile.className = 'tile' + (value === 0 ? ' empty' : '');
                    tile.textContent = value === 0 ? '' : value;
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    
                    tile.addEventListener('click', () => handleTileClick(row, col));
                    
                    boardEl.appendChild(tile);
                }
            }
            
            highlightMovableTiles();
        }

        // Highlight tiles that can be moved
        function highlightMovableTiles() {
            // Remove highlights from all tiles
            document.querySelectorAll('.tile').forEach(tile => {
                tile.classList.remove('movable');
            });
            
            const { row, col } = state.emptyPos;
            
            // Check adjacent tiles
            const directions = [
                { dr: -1, dc: 0 }, // Up
                { dr: 1, dc: 0 },  // Down
                { dr: 0, dc: -1 }, // Left
                { dr: 0, dc: 1 }   // Right
            ];
            
            for (const { dr, dc } of directions) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3) {
                    const tile = document.querySelector(`.tile[data-row="${newRow}"][data-col="${newCol}"]`);
                    if (tile) {
                        tile.classList.add('movable');
                    }
                }
            }
        }

        // Handle tile click
        function handleTileClick(row, col) {
            if (state.board[row][col] === 0) return;
            
            // Check if the clicked tile is adjacent to the empty space
            const rowDiff = Math.abs(row - state.emptyPos.row);
            const colDiff = Math.abs(col - state.emptyPos.col);
            
            if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                // Move the tile
                state.board[state.emptyPos.row][state.emptyPos.col] = state.board[row][col];
                state.board[row][col] = 0;
                state.emptyPos = { row, col };
                state.stats.moves++;
                
                updateBoard();
                highlightMovableTiles();
                updateStats();
            }
        }

        // Update the board display
        function updateBoard() {
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const value = state.board[row][col];
                    const tile = document.querySelector(`.tile[data-row="${row}"][data-col="${col}"]`);
                    if (tile) {
                        tile.textContent = value === 0 ? '' : value;
                        tile.className = 'tile' + (value === 0 ? ' empty' : '');
                    }
                }
            }
        }

        // Shuffle the board
        function shuffleBoard() {
            if (state.isSolving) return;
            
            resetSolution();
            
            // Perform random valid moves
            for (let i = 0; i < 100; i++) {
                const { row, col } = state.emptyPos;
                const possibleMoves = [];
                
                // Check possible moves
                if (row > 0) possibleMoves.push({ row: row - 1, col }); // Up
                if (row < 2) possibleMoves.push({ row: row + 1, col }); // Down
                if (col > 0) possibleMoves.push({ row, col: col - 1 }); // Left
                if (col < 2) possibleMoves.push({ row, col: col + 1 }); // Right
                
                // Randomly select a move
                const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                
                // Execute the move
                state.board[row][col] = state.board[move.row][move.col];
                state.board[move.row][move.col] = 0;
                state.emptyPos = move;
            }
            
            state.stats.moves = 0;
            updateBoard();
            highlightMovableTiles();
            updateStats();
        }

        // Solve the puzzle using Worker API to run the A* algorithm
        function solvePuzzle() {
            if (state.isSolving) return;
            
            state.isSolving = true;
            state.cancelSolve = false;
            loadingModal.style.display = 'flex';
            solveBtn.disabled = true;
            
            // Create a worker from the Blob URL
            const workerCode = `
                // Worker implementation of A* algorithm
                ${solvePuzzle.toString()}
                
                // Structure to represent a puzzle state
                function PuzzleState(board, g, h, blankPos, path) {
                    this.board = board;
                    this.g = g;
                    this.h = h;
                    this.blankPos = blankPos;
                    this.path = path;
                    
                    this.cost = function() { return this.g + this.h; };
                }
                
                // Manhattan Distance heuristic
                function manhattanDistance(board) {
                    let distance = 0;
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            if (board[i][j] === 0) continue;
                            const targetRow = Math.floor((board[i][j] - 1) / 3);
                            const targetCol = (board[i][j] - 1) % 3;
                            distance += Math.abs(i - targetRow) + Math.abs(j - targetCol);
                        }
                    }
                    return distance;
                }
                
                // Convert board to string for hashing
                function boardToString(board) {
                    return board.flat().join('');
                }
                
                // Generate neighboring states
                function getNeighbors(state) {
                    const neighbors = [];
                    const directions = [
                        { dr: -1, dc: 0, name: "Up" },
                        { dr: 1, dc: 0, name: "Down" },
                        { dr: 0, dc: -1, name: "Left" },
                        { dr: 0, dc: 1, name: "Right" }
                    ];
                
                    for (const dir of directions) {
                        const newRow = state.blankPos.row + dir.dr;
                        const newCol = state.blankPos.col + dir.dc;
                
                        if (newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3) {
                            // Clone the board
                            const newBoard = state.board.map(row => [...row]);
                            
                            // Swap tiles
                            [newBoard[state.blankPos.row][state.blankPos.col], newBoard[newRow][newCol]] = 
                                [newBoard[newRow][newCol], newBoard[state.blankPos.row][state.blankPos.col]];
                            
                            // Create new state
                            const newPath = [...state.path, dir.name];
                            const newState = new PuzzleState(
                                newBoard,
                                state.g + 1,
                                manhattanDistance(newBoard),
                                { row: newRow, col: newCol },
                                newPath
                            );
                            
                            neighbors.push(newState);
                        }
                    }
                
                    return neighbors;
                }
                
                // Function to solve the puzzle using A* search
                function solvePuzzle(startBoard) {
                    const goalBoard = [[1, 2, 3], [4, 5, 6], [7, 8, 0]];
                    
                    // Priority queue (min-heap based on cost)
                    const pq = [];
                    function enqueue(state) {
                        pq.push(state);
                        pq.sort((a, b) => a.cost() - b.cost());
                    }
                    function dequeue() {
                        return pq.shift();
                    }
                    
                    const visited = new Set();
                    
                    // Find initial blank position
                    let blankPos = { row: 0, col: 0 };
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 3; j++) {
                            if (startBoard[i][j] === 0) {
                                blankPos = { row: i, col: j };
                                break;
                            }
                        }
                    }
                    
                    // Initial state
                    const initialState = new PuzzleState(
                        startBoard,
                        0,
                        manhattanDistance(startBoard),
                        blankPos,
                        []
                    );
                    
                    enqueue(initialState);
                    let statesExplored = 0;
                    
                    while (pq.length > 0) {
                        const current = dequeue();
                        statesExplored++;
                        
                        // Report progress periodically
                        if (statesExplored % 1000 === 0) {
                            postMessage({ type: 'progress', statesExplored });
                        }
                        
                        // Check if current state is the goal
                        let isGoal = true;
                        for (let i = 0; i < 3; i++) {
                            for (let j = 0; j < 3; j++) {
                                if (current.board[i][j] !== goalBoard[i][j]) {
                                    isGoal = false;
                                    break;
                                }
                            }
                            if (!isGoal) break;
                        }
                        
                        if (isGoal) {
                            return { solution: current.path, statesExplored };
                        }
                        
                        const boardStr = boardToString(current.board);
                        if (visited.has(boardStr)) {
                            continue;
                        }
                        visited.add(boardStr);
                        
                        // Explore neighbors
                        for (const neighbor of getNeighbors(current)) {
                            const neighborStr = boardToString(neighbor.board);
                            if (!visited.has(neighborStr)) {
                                enqueue(neighbor);
                            }
                        }
                    }
                    
                    return { solution: [], statesExplored }; // No solution found
                }
                
                // Worker message handler
                self.onmessage = function(e) {
                    const { startBoard } = e.data;
                    const result = solvePuzzle(startBoard);
                    postMessage({ type: 'result', ...result });
                };
            `;
            
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            const worker = new Worker(workerUrl);
            
            worker.onmessage = function(e) {
                if (e.data.type === 'result') {
                    worker.terminate();
                    URL.revokeObjectURL(workerUrl);
                    loadingModal.style.display = 'none';
                    solveBtn.disabled = false;
                    state.isSolving = false;
                    
                    state.solution = e.data.solution;
                    state.stats.statesExplored = e.data.statesExplored;
                    state.currentStep = -1;
                    updateStats();
                    
                    if (state.solution.length === 0) {
                        solutionEl.innerHTML = '<p style="color: #e74c3c;">No solution exists for this configuration!</p>';
                    } else {
                        displaySolution();
                        prevBtn.disabled = true;
                        nextBtn.disabled = false;
                        playBtn.disabled = false;
                    }
                } else if (e.data.type === 'progress') {
                    solveProgressEl.textContent = `States explored: ${e.data.statesExplored}`;
                }
            };
            
            worker.onerror = function(error) {
                console.error('Worker error:', error);
                loadingModal.style.display = 'none';
                solveBtn.disabled = false;
                state.isSolving = false;
                solutionEl.innerHTML = '<p style="color: #e74c3c;">Error occurred while solving the puzzle.</p>';
            };
            
            worker.postMessage({ startBoard: state.board });
        }

        // Display solution steps
        function displaySolution() {
            solutionEl.innerHTML = '';
            
            if (state.solution.length === 0) {
                solutionEl.innerHTML = '<p style="text-align: center; color: #7f8c8d;">No solution found</p>';
                return;
            }
            
            for (let i = 0; i < state.solution.length; i++) {
                const step = document.createElement('div');
                step.className = 'solution-step' + (i === state.currentStep ? ' active' : '');
                step.innerHTML = `
                    <span>Step ${i + 1}</span>
                    <span>${state.solution[i]}</span>
                `;
                
                step.addEventListener('click', () => {
                    if (state.autoPlayInterval) {
                        clearInterval(state.autoPlayInterval);
                        state.autoPlayInterval = null;
                        playBtn.textContent = 'Play Solution';
                    }
                    gotoStep(i);
                });
                
                solutionEl.appendChild(step);
            }
            
            // Scroll to current step if applicable
            if (state.currentStep >= 0) {
                document.querySelectorAll('.solution-step')[state.currentStep].scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest'
                });
            }
        }

        // Go to specific step in solution
        function gotoStep(step) {
            if (step < -1 || step >= state.solution.length) return;
            
            // Reset to initial state if going before step 0
            if (step === -1) {
                resetBoardToInitial();
                state.currentStep = -1;
                updateButtons();
                displaySolution();
                return;
            }
            
            // Calculate the difference from current step
            const diff = step - state.currentStep;
            
            // Execute the moves
            for (let i = 0; i < Math.abs(diff); i++) {
                if (diff > 0) {
                    executeMove(state.solution[state.currentStep + 1 + i]);
                } else {
                    // For going backwards, we need to reverse the moves
                    const reverseMove = getReverseMove(state.solution[state.currentStep - i - 1]);
                    executeMove(reverseMove);
                }
            }
            
            state.currentStep = step;
            updateButtons();
            displaySolution();
        }

        // Execute a single move
        function executeMove(direction) {
            const { row, col } = state.emptyPos;
            let newRow = row, newCol = col;
            
            switch (direction) {
                case 'Up': newRow = row + 1; break;
                case 'Down': newRow = row - 1; break;
                case 'Left': newCol = col + 1; break;
                case 'Right': newCol = col - 1; break;
            }
            
            // Swap tiles
            state.board[row][col] = state.board[newRow][newCol];
            state.board[newRow][newCol] = 0;
            state.emptyPos = { row: newRow, col: newCol };
            
            updateBoard();
            highlightMovableTiles();
        }

        // Get reverse direction for a move
        function getReverseMove(direction) {
            switch (direction) {
                case 'Up': return 'Down';
                case 'Down': return 'Up';
                case 'Left': return 'Right';
                case 'Right': return 'Left';
            }
        }

        // Reset board to initial state (before solution)
        function resetBoardToInitial() {
            // We need to reverse all moves applied so far
            for (let i = state.currentStep; i >= 0; i--) {
                const reverseMove = getReverseMove(state.solution[i]);
                executeMove(reverseMove);
            }
        }

        // Update navigation buttons state
        function updateButtons() {
            prevBtn.disabled = state.currentStep <= -1;
            nextBtn.disabled = state.currentStep >= state.solution.length - 1;
        }

        // Reset the solution tracking
        function resetSolution() {
            if (state.autoPlayInterval) {
                clearInterval(state.autoPlayInterval);
                state.autoPlayInterval = null;
                playBtn.textContent = 'Play Solution';
            }
            
            state.solution = [];
            state.currentStep = -1;
            solutionEl.innerHTML = '<p style="text-align: center; color: #7f8c8d;">Solution will appear here</p>';
            
            prevBtn.disabled = true;
            nextBtn.disabled = true;
            playBtn.disabled = true;
        }

        // Reset board to initial configuration
        function resetBoard() {
            if (state.isSolving) return;
            
            state.board = [[1, 2, 3], [4, 5, 6], [7, 8, 0]];
            state.emptyPos = { row: 2, col: 2 };
            state.stats.moves = 0;
            
            resetSolution();
            updateBoard();
            highlightMovableTiles();
            updateStats();
        }

        // Play through the solution automatically
        function playSolution() {
            if (state.autoPlayInterval) {
                clearInterval(state.autoPlayInterval);
                state.autoPlayInterval = null;
                playBtn.textContent = 'Play Solution';
                return;
            }
            
            if (state.currentStep >= state.solution.length - 1) {
                state.currentStep = -1;
                resetBoardToInitial();
                updateButtons();
                displaySolution();
            }
            
            playBtn.textContent = 'Playing...';
            
            state.autoPlayInterval = setInterval(() => {
                if (state.currentStep < state.solution.length - 1) {
                    gotoStep(state.currentStep + 1);
                } else {
                    clearInterval(state.autoPlayInterval);
                    state.autoPlayInterval = null;
                    playBtn.textContent = 'Play Solution';
                }
            }, 500);
        }

        // Update statistics display
        function updateStats() {
            movesCountEl.textContent = state.stats.moves;
            timeTakenEl.textContent = state.stats.timeTaken;
            statesExploredEl.textContent = state.stats.statesExplored;
        }

        // Handle keyboard input
        function handleKeyDown(e) {
            if (state.isSolving || state.autoPlayInterval) return;
            
            const directions = {
                'ArrowUp': 'Up',
                'ArrowDown': 'Down',
                'ArrowLeft': 'Left',
                'ArrowRight': 'Right'
            };
            
            if (directions[e.key] && document.activeElement === boardEl) {
                e.preventDefault();
                
                const direction = directions[e.key];
                const { row, col } = state.emptyPos;
                let newRow = row, newCol = col;
                
                switch (direction) {
                    case 'Up': newRow = row + 1; break;
                    case 'Down': newRow = row - 1; break;
                    case 'Left': newCol = col + 1; break;
                    case 'Right': newCol = col - 1; break;
                }
                
                if (newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3) {
                    // Move the tile
                    state.board[row][col] = state.board[newRow][newCol];
                    state.board[newRow][newCol] = 0;
                    state.emptyPos = { row: newRow, col: newCol };
                    state.stats.moves++;
                    
                    resetSolution();
                    updateBoard();
                    highlightMovableTiles();
                    updateStats();
                }
            }
        }

        // Event listeners
        shuffleBtn.addEventListener('click', shuffleBoard);
        solveBtn.addEventListener('click', solvePuzzle);
        resetBtn.addEventListener('click', resetBoard);
        prevBtn.addEventListener('click', () => gotoStep(state.currentStep - 1));
        nextBtn.addEventListener('click', () => gotoStep(state.currentStep + 1));
        playBtn.addEventListener('click', playSolution);
        cancelSolveBtn.addEventListener('click', () => {
            state.cancelSolve = true;
            loadingModal.style.display = 'none';
            solveBtn.disabled = false;
        });
        boardEl.addEventListener('keydown', handleKeyDown);
        boardEl.setAttribute('tabindex', '0'); // Make board focusable for keyboard input

        // Initialize
        initBoard();
        updateStats();
    </script>
</body>
</html>
